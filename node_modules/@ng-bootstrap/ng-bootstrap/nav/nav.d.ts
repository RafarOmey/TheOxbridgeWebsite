import { AfterContentChecked, AfterContentInit, ChangeDetectorRef, ElementRef, EventEmitter, OnInit, QueryList, TemplateRef } from '@angular/core';
import { NgbNavConfig } from './nav-config';
/**
 * Context passed to the nav content template.
 *
 * See [this demo](#/components/nav/examples#keep-content) as the example.
 *
 * @since 5.2.0
 */
import * as ɵngcc0 from '@angular/core';
export interface NgbNavContentContext {
    /**
     * If `true`, current nav content is visible and active
     */
    $implicit: boolean;
}
/**
 * This directive must be used to wrap content to be displayed in the nav.
 *
 * @since 5.2.0
 */
export declare class NgbNavContent {
    templateRef: TemplateRef<any>;
    constructor(templateRef: TemplateRef<any>);
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NgbNavContent>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<NgbNavContent, "ng-template[ngbNavContent]", never, {}, {}, never>;
}
/**
 * The directive used to group nav link and related nav content. As well as set nav identifier and some options.
 *
 * @since 5.2.0
 */
export declare class NgbNavItem implements AfterContentChecked, OnInit {
    elementRef: ElementRef<any>;
    private _nav;
    /**
     * If `true`, non-active current nav item content will be removed from DOM
     * Otherwise it will just be hidden
     */
    destroyOnHide: any;
    /**
     * If `true`, the current nav item is disabled and can't be toggled by user.
     *
     * Nevertheless disabled nav can be selected programmatically via the `.select()` method and the `[activeId]` binding.
     */
    disabled: boolean;
    /**
     * The id used for the DOM elements.
     * Must be unique inside the document in case you have multiple `ngbNav`s on the page.
     *
     * Autogenerated as `ngb-nav-XXX` if not provided.
     */
    domId: string;
    /**
     * The id used as a model for active nav.
     * It can be anything, but must be unique inside one `ngbNav`.
     *
     * The only limitation is that it is not possible to have the `''` (empty string) as id,
     * because ` ngbNavItem `, `ngbNavItem=''` and `[ngbNavItem]="''"` are indistinguishable
     */
    _id: any;
    contentTpl: NgbNavContent | null;
    contentTpls: QueryList<NgbNavContent>;
    constructor(nav: any, elementRef: ElementRef<any>);
    ngAfterContentChecked(): void;
    ngOnInit(): void;
    get active(): boolean;
    get id(): any;
    get panelDomId(): string;
    isPanelInDom(): boolean;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NgbNavItem>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<NgbNavItem, "[ngbNavItem]", ["ngbNavItem"], {
    "disabled": "disabled";
    "domId": "domId";
    "destroyOnHide": "destroyOnHide";
    "_id": "ngbNavItem";
}, {}, ["contentTpls"]>;
}
/**
 * A nav directive that helps with implementing tabbed navigation components.
 *
 * @since 5.2.0
 */
export declare class NgbNav implements AfterContentInit {
    role: string;
    private _cd;
    private _document;
    static ngAcceptInputType_orientation: string;
    static ngAcceptInputType_roles: boolean | string;
    /**
     * The id of the nav that should be active
     *
     * You could also use the `.select()` method and the `(navChange)` event
     */
    activeId: any;
    /**
     * The event emitted after the active nav changes
     * The payload of the event is the newly active nav id
     *
     * If you want to prevent nav change, you should use `(navChange)` event
     */
    activeIdChange: EventEmitter<any>;
    /**
     * If `true`, non-active nav content will be removed from DOM
     * Otherwise it will just be hidden
     */
    destroyOnHide: any;
    /**
     * The orientation of navs.
     *
     * Using `vertical` will also add the `aria-orientation` attribute
     */
    orientation: 'horizontal' | 'vertical';
    /**
     * Role attribute generating strategy:
     * - `false` - no role attributes will be generated
     * - `'tablist'` - 'tablist', 'tab' and 'tabpanel' will be generated (default)
     */
    roles: 'tablist' | false;
    /**
     * Keyboard support for nav focus/selection using arrow keys.
     *
     * * `false` - no keyboard support.
     * * `true` - navs will be focused using keyboard arrow keys
     * * `'changeWithArrows'` -  nav will be selected using keyboard arrow keys
     *
     * See the [list of available keyboard shortcuts](#/components/nav/overview#keyboard-shortcuts).
     *
     * @since 6.1.0
   */
    keyboard: boolean | 'changeWithArrows';
    items: QueryList<NgbNavItem>;
    links: QueryList<NgbNavLink>;
    constructor(role: string, config: NgbNavConfig, _cd: ChangeDetectorRef, _document: any);
    /**
     * The nav change event emitted right before the nav change happens on user click.
     *
     * This event won't be emitted if nav is changed programmatically via `[activeId]` or `.select()`.
     *
     * See [`NgbNavChangeEvent`](#/components/nav/api#NgbNavChangeEvent) for payload details.
     */
    navChange: EventEmitter<NgbNavChangeEvent<any>>;
    click(item: NgbNavItem): void;
    onKeyDown(event: KeyboardEvent): void;
    /**
     * Selects the nav with the given id and shows its associated pane.
     * Any other nav that was previously selected becomes unselected and its associated pane is hidden.
     */
    select(id: any): void;
    ngAfterContentInit(): void;
    private _updateActiveId;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NgbNav>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<NgbNav, "[ngbNav]", ["ngbNav"], {
    "destroyOnHide": "destroyOnHide";
    "orientation": "orientation";
    "roles": "roles";
    "keyboard": "keyboard";
    "activeId": "activeId";
}, {
    "activeIdChange": "activeIdChange";
    "navChange": "navChange";
}, ["items", "links"]>;
}
/**
 * A directive to put on the nav link.
 *
 * @since 5.2.0
 */
export declare class NgbNavLink {
    role: string;
    navItem: NgbNavItem;
    nav: NgbNav;
    elRef: ElementRef;
    constructor(role: string, navItem: NgbNavItem, nav: NgbNav, elRef: ElementRef);
    hasNavItemClass(): boolean;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NgbNavLink>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<NgbNavLink, "a[ngbNavLink]", never, {}, {}, never>;
}
/**
 * The payload of the change event emitted right before the nav change happens on user click.
 *
 * This event won't be emitted if nav is changed programmatically via `[activeId]` or `.select()`.
 *
 * @since 5.2.0
 */
export interface NgbNavChangeEvent<T = any> {
    /**
     * Id of the currently active nav.
     */
    activeId: T;
    /**
     * Id of the newly selected nav.
     */
    nextId: T;
    /**
     * Function that will prevent nav change if called.
     */
    preventDefault: () => void;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmF2LmQudHMiLCJzb3VyY2VzIjpbIm5hdi5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7O0FBU0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUFjQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNENBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMEVBOzs7Ozs7Ozs7Ozs7Ozs7QUFhQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFmdGVyQ29udGVudENoZWNrZWQsIEFmdGVyQ29udGVudEluaXQsIENoYW5nZURldGVjdG9yUmVmLCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIE9uSW5pdCwgUXVlcnlMaXN0LCBUZW1wbGF0ZVJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTmdiTmF2Q29uZmlnIH0gZnJvbSAnLi9uYXYtY29uZmlnJztcbi8qKlxuICogQ29udGV4dCBwYXNzZWQgdG8gdGhlIG5hdiBjb250ZW50IHRlbXBsYXRlLlxuICpcbiAqIFNlZSBbdGhpcyBkZW1vXSgjL2NvbXBvbmVudHMvbmF2L2V4YW1wbGVzI2tlZXAtY29udGVudCkgYXMgdGhlIGV4YW1wbGUuXG4gKlxuICogQHNpbmNlIDUuMi4wXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTmdiTmF2Q29udGVudENvbnRleHQge1xuICAgIC8qKlxuICAgICAqIElmIGB0cnVlYCwgY3VycmVudCBuYXYgY29udGVudCBpcyB2aXNpYmxlIGFuZCBhY3RpdmVcbiAgICAgKi9cbiAgICAkaW1wbGljaXQ6IGJvb2xlYW47XG59XG4vKipcbiAqIFRoaXMgZGlyZWN0aXZlIG11c3QgYmUgdXNlZCB0byB3cmFwIGNvbnRlbnQgdG8gYmUgZGlzcGxheWVkIGluIHRoZSBuYXYuXG4gKlxuICogQHNpbmNlIDUuMi4wXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIE5nYk5hdkNvbnRlbnQge1xuICAgIHRlbXBsYXRlUmVmOiBUZW1wbGF0ZVJlZjxhbnk+O1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlUmVmOiBUZW1wbGF0ZVJlZjxhbnk+KTtcbn1cbi8qKlxuICogVGhlIGRpcmVjdGl2ZSB1c2VkIHRvIGdyb3VwIG5hdiBsaW5rIGFuZCByZWxhdGVkIG5hdiBjb250ZW50LiBBcyB3ZWxsIGFzIHNldCBuYXYgaWRlbnRpZmllciBhbmQgc29tZSBvcHRpb25zLlxuICpcbiAqIEBzaW5jZSA1LjIuMFxuICovXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBOZ2JOYXZJdGVtIGltcGxlbWVudHMgQWZ0ZXJDb250ZW50Q2hlY2tlZCwgT25Jbml0IHtcbiAgICBlbGVtZW50UmVmOiBFbGVtZW50UmVmPGFueT47XG4gICAgcHJpdmF0ZSBfbmF2O1xuICAgIC8qKlxuICAgICAqIElmIGB0cnVlYCwgbm9uLWFjdGl2ZSBjdXJyZW50IG5hdiBpdGVtIGNvbnRlbnQgd2lsbCBiZSByZW1vdmVkIGZyb20gRE9NXG4gICAgICogT3RoZXJ3aXNlIGl0IHdpbGwganVzdCBiZSBoaWRkZW5cbiAgICAgKi9cbiAgICBkZXN0cm95T25IaWRlOiBhbnk7XG4gICAgLyoqXG4gICAgICogSWYgYHRydWVgLCB0aGUgY3VycmVudCBuYXYgaXRlbSBpcyBkaXNhYmxlZCBhbmQgY2FuJ3QgYmUgdG9nZ2xlZCBieSB1c2VyLlxuICAgICAqXG4gICAgICogTmV2ZXJ0aGVsZXNzIGRpc2FibGVkIG5hdiBjYW4gYmUgc2VsZWN0ZWQgcHJvZ3JhbW1hdGljYWxseSB2aWEgdGhlIGAuc2VsZWN0KClgIG1ldGhvZCBhbmQgdGhlIGBbYWN0aXZlSWRdYCBiaW5kaW5nLlxuICAgICAqL1xuICAgIGRpc2FibGVkOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFRoZSBpZCB1c2VkIGZvciB0aGUgRE9NIGVsZW1lbnRzLlxuICAgICAqIE11c3QgYmUgdW5pcXVlIGluc2lkZSB0aGUgZG9jdW1lbnQgaW4gY2FzZSB5b3UgaGF2ZSBtdWx0aXBsZSBgbmdiTmF2YHMgb24gdGhlIHBhZ2UuXG4gICAgICpcbiAgICAgKiBBdXRvZ2VuZXJhdGVkIGFzIGBuZ2ItbmF2LVhYWGAgaWYgbm90IHByb3ZpZGVkLlxuICAgICAqL1xuICAgIGRvbUlkOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogVGhlIGlkIHVzZWQgYXMgYSBtb2RlbCBmb3IgYWN0aXZlIG5hdi5cbiAgICAgKiBJdCBjYW4gYmUgYW55dGhpbmcsIGJ1dCBtdXN0IGJlIHVuaXF1ZSBpbnNpZGUgb25lIGBuZ2JOYXZgLlxuICAgICAqXG4gICAgICogVGhlIG9ubHkgbGltaXRhdGlvbiBpcyB0aGF0IGl0IGlzIG5vdCBwb3NzaWJsZSB0byBoYXZlIHRoZSBgJydgIChlbXB0eSBzdHJpbmcpIGFzIGlkLFxuICAgICAqIGJlY2F1c2UgYCBuZ2JOYXZJdGVtIGAsIGBuZ2JOYXZJdGVtPScnYCBhbmQgYFtuZ2JOYXZJdGVtXT1cIicnXCJgIGFyZSBpbmRpc3Rpbmd1aXNoYWJsZVxuICAgICAqL1xuICAgIF9pZDogYW55O1xuICAgIGNvbnRlbnRUcGw6IE5nYk5hdkNvbnRlbnQgfCBudWxsO1xuICAgIGNvbnRlbnRUcGxzOiBRdWVyeUxpc3Q8TmdiTmF2Q29udGVudD47XG4gICAgY29uc3RydWN0b3IobmF2OiBhbnksIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWY8YW55Pik7XG4gICAgbmdBZnRlckNvbnRlbnRDaGVja2VkKCk6IHZvaWQ7XG4gICAgbmdPbkluaXQoKTogdm9pZDtcbiAgICBnZXQgYWN0aXZlKCk6IGJvb2xlYW47XG4gICAgZ2V0IGlkKCk6IGFueTtcbiAgICBnZXQgcGFuZWxEb21JZCgpOiBzdHJpbmc7XG4gICAgaXNQYW5lbEluRG9tKCk6IGJvb2xlYW47XG59XG4vKipcbiAqIEEgbmF2IGRpcmVjdGl2ZSB0aGF0IGhlbHBzIHdpdGggaW1wbGVtZW50aW5nIHRhYmJlZCBuYXZpZ2F0aW9uIGNvbXBvbmVudHMuXG4gKlxuICogQHNpbmNlIDUuMi4wXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIE5nYk5hdiBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQge1xuICAgIHJvbGU6IHN0cmluZztcbiAgICBwcml2YXRlIF9jZDtcbiAgICBwcml2YXRlIF9kb2N1bWVudDtcbiAgICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfb3JpZW50YXRpb246IHN0cmluZztcbiAgICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfcm9sZXM6IGJvb2xlYW4gfCBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogVGhlIGlkIG9mIHRoZSBuYXYgdGhhdCBzaG91bGQgYmUgYWN0aXZlXG4gICAgICpcbiAgICAgKiBZb3UgY291bGQgYWxzbyB1c2UgdGhlIGAuc2VsZWN0KClgIG1ldGhvZCBhbmQgdGhlIGAobmF2Q2hhbmdlKWAgZXZlbnRcbiAgICAgKi9cbiAgICBhY3RpdmVJZDogYW55O1xuICAgIC8qKlxuICAgICAqIFRoZSBldmVudCBlbWl0dGVkIGFmdGVyIHRoZSBhY3RpdmUgbmF2IGNoYW5nZXNcbiAgICAgKiBUaGUgcGF5bG9hZCBvZiB0aGUgZXZlbnQgaXMgdGhlIG5ld2x5IGFjdGl2ZSBuYXYgaWRcbiAgICAgKlxuICAgICAqIElmIHlvdSB3YW50IHRvIHByZXZlbnQgbmF2IGNoYW5nZSwgeW91IHNob3VsZCB1c2UgYChuYXZDaGFuZ2UpYCBldmVudFxuICAgICAqL1xuICAgIGFjdGl2ZUlkQ2hhbmdlOiBFdmVudEVtaXR0ZXI8YW55PjtcbiAgICAvKipcbiAgICAgKiBJZiBgdHJ1ZWAsIG5vbi1hY3RpdmUgbmF2IGNvbnRlbnQgd2lsbCBiZSByZW1vdmVkIGZyb20gRE9NXG4gICAgICogT3RoZXJ3aXNlIGl0IHdpbGwganVzdCBiZSBoaWRkZW5cbiAgICAgKi9cbiAgICBkZXN0cm95T25IaWRlOiBhbnk7XG4gICAgLyoqXG4gICAgICogVGhlIG9yaWVudGF0aW9uIG9mIG5hdnMuXG4gICAgICpcbiAgICAgKiBVc2luZyBgdmVydGljYWxgIHdpbGwgYWxzbyBhZGQgdGhlIGBhcmlhLW9yaWVudGF0aW9uYCBhdHRyaWJ1dGVcbiAgICAgKi9cbiAgICBvcmllbnRhdGlvbjogJ2hvcml6b250YWwnIHwgJ3ZlcnRpY2FsJztcbiAgICAvKipcbiAgICAgKiBSb2xlIGF0dHJpYnV0ZSBnZW5lcmF0aW5nIHN0cmF0ZWd5OlxuICAgICAqIC0gYGZhbHNlYCAtIG5vIHJvbGUgYXR0cmlidXRlcyB3aWxsIGJlIGdlbmVyYXRlZFxuICAgICAqIC0gYCd0YWJsaXN0J2AgLSAndGFibGlzdCcsICd0YWInIGFuZCAndGFicGFuZWwnIHdpbGwgYmUgZ2VuZXJhdGVkIChkZWZhdWx0KVxuICAgICAqL1xuICAgIHJvbGVzOiAndGFibGlzdCcgfCBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBLZXlib2FyZCBzdXBwb3J0IGZvciBuYXYgZm9jdXMvc2VsZWN0aW9uIHVzaW5nIGFycm93IGtleXMuXG4gICAgICpcbiAgICAgKiAqIGBmYWxzZWAgLSBubyBrZXlib2FyZCBzdXBwb3J0LlxuICAgICAqICogYHRydWVgIC0gbmF2cyB3aWxsIGJlIGZvY3VzZWQgdXNpbmcga2V5Ym9hcmQgYXJyb3cga2V5c1xuICAgICAqICogYCdjaGFuZ2VXaXRoQXJyb3dzJ2AgLSAgbmF2IHdpbGwgYmUgc2VsZWN0ZWQgdXNpbmcga2V5Ym9hcmQgYXJyb3cga2V5c1xuICAgICAqXG4gICAgICogU2VlIHRoZSBbbGlzdCBvZiBhdmFpbGFibGUga2V5Ym9hcmQgc2hvcnRjdXRzXSgjL2NvbXBvbmVudHMvbmF2L292ZXJ2aWV3I2tleWJvYXJkLXNob3J0Y3V0cykuXG4gICAgICpcbiAgICAgKiBAc2luY2UgNi4xLjBcbiAgICovXG4gICAga2V5Ym9hcmQ6IGJvb2xlYW4gfCAnY2hhbmdlV2l0aEFycm93cyc7XG4gICAgaXRlbXM6IFF1ZXJ5TGlzdDxOZ2JOYXZJdGVtPjtcbiAgICBsaW5rczogUXVlcnlMaXN0PE5nYk5hdkxpbms+O1xuICAgIGNvbnN0cnVjdG9yKHJvbGU6IHN0cmluZywgY29uZmlnOiBOZ2JOYXZDb25maWcsIF9jZDogQ2hhbmdlRGV0ZWN0b3JSZWYsIF9kb2N1bWVudDogYW55KTtcbiAgICAvKipcbiAgICAgKiBUaGUgbmF2IGNoYW5nZSBldmVudCBlbWl0dGVkIHJpZ2h0IGJlZm9yZSB0aGUgbmF2IGNoYW5nZSBoYXBwZW5zIG9uIHVzZXIgY2xpY2suXG4gICAgICpcbiAgICAgKiBUaGlzIGV2ZW50IHdvbid0IGJlIGVtaXR0ZWQgaWYgbmF2IGlzIGNoYW5nZWQgcHJvZ3JhbW1hdGljYWxseSB2aWEgYFthY3RpdmVJZF1gIG9yIGAuc2VsZWN0KClgLlxuICAgICAqXG4gICAgICogU2VlIFtgTmdiTmF2Q2hhbmdlRXZlbnRgXSgjL2NvbXBvbmVudHMvbmF2L2FwaSNOZ2JOYXZDaGFuZ2VFdmVudCkgZm9yIHBheWxvYWQgZGV0YWlscy5cbiAgICAgKi9cbiAgICBuYXZDaGFuZ2U6IEV2ZW50RW1pdHRlcjxOZ2JOYXZDaGFuZ2VFdmVudDxhbnk+PjtcbiAgICBjbGljayhpdGVtOiBOZ2JOYXZJdGVtKTogdm9pZDtcbiAgICBvbktleURvd24oZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFNlbGVjdHMgdGhlIG5hdiB3aXRoIHRoZSBnaXZlbiBpZCBhbmQgc2hvd3MgaXRzIGFzc29jaWF0ZWQgcGFuZS5cbiAgICAgKiBBbnkgb3RoZXIgbmF2IHRoYXQgd2FzIHByZXZpb3VzbHkgc2VsZWN0ZWQgYmVjb21lcyB1bnNlbGVjdGVkIGFuZCBpdHMgYXNzb2NpYXRlZCBwYW5lIGlzIGhpZGRlbi5cbiAgICAgKi9cbiAgICBzZWxlY3QoaWQ6IGFueSk6IHZvaWQ7XG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCk6IHZvaWQ7XG4gICAgcHJpdmF0ZSBfdXBkYXRlQWN0aXZlSWQ7XG59XG4vKipcbiAqIEEgZGlyZWN0aXZlIHRvIHB1dCBvbiB0aGUgbmF2IGxpbmsuXG4gKlxuICogQHNpbmNlIDUuMi4wXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIE5nYk5hdkxpbmsge1xuICAgIHJvbGU6IHN0cmluZztcbiAgICBuYXZJdGVtOiBOZ2JOYXZJdGVtO1xuICAgIG5hdjogTmdiTmF2O1xuICAgIGVsUmVmOiBFbGVtZW50UmVmO1xuICAgIGNvbnN0cnVjdG9yKHJvbGU6IHN0cmluZywgbmF2SXRlbTogTmdiTmF2SXRlbSwgbmF2OiBOZ2JOYXYsIGVsUmVmOiBFbGVtZW50UmVmKTtcbiAgICBoYXNOYXZJdGVtQ2xhc3MoKTogYm9vbGVhbjtcbn1cbi8qKlxuICogVGhlIHBheWxvYWQgb2YgdGhlIGNoYW5nZSBldmVudCBlbWl0dGVkIHJpZ2h0IGJlZm9yZSB0aGUgbmF2IGNoYW5nZSBoYXBwZW5zIG9uIHVzZXIgY2xpY2suXG4gKlxuICogVGhpcyBldmVudCB3b24ndCBiZSBlbWl0dGVkIGlmIG5hdiBpcyBjaGFuZ2VkIHByb2dyYW1tYXRpY2FsbHkgdmlhIGBbYWN0aXZlSWRdYCBvciBgLnNlbGVjdCgpYC5cbiAqXG4gKiBAc2luY2UgNS4yLjBcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBOZ2JOYXZDaGFuZ2VFdmVudDxUID0gYW55PiB7XG4gICAgLyoqXG4gICAgICogSWQgb2YgdGhlIGN1cnJlbnRseSBhY3RpdmUgbmF2LlxuICAgICAqL1xuICAgIGFjdGl2ZUlkOiBUO1xuICAgIC8qKlxuICAgICAqIElkIG9mIHRoZSBuZXdseSBzZWxlY3RlZCBuYXYuXG4gICAgICovXG4gICAgbmV4dElkOiBUO1xuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRoYXQgd2lsbCBwcmV2ZW50IG5hdiBjaGFuZ2UgaWYgY2FsbGVkLlxuICAgICAqL1xuICAgIHByZXZlbnREZWZhdWx0OiAoKSA9PiB2b2lkO1xufVxuIl19